原理解析：   
我们可以同时去一个地方“占坑”，如果占到，就执行逻辑。否则就必须等待，直到释放锁。“占坑”可以去redis，可以去数据库，可以去任何大家都能访问的地方。等待可以自旋的方式。

1. 没有设置过期时间，本机宕机或者崩溃，造成死锁

2. 设置过期时间不是原子性的，在设置过期时间的过程中宕机了，造成死锁

3. 原子设置过期时间，但是由于业务执行时间超长，锁已过期，导致删除了别人的锁。

   解决方案：设置uuid， 删除锁前获取锁，只有是自己的uuid，才去删除处理

4. 如果正好判断是当前值，正要删除锁的时候，锁已经过期，别人已经设置到了新的值。那么我们删除的是别人的锁

   解决思路：删除锁必须保证原子性。使用redis+Lua脚本完成

5. 终极版本，大量请求过来争抢锁，导致请求大量堆积，线程等待时间长，非公平。。。。。